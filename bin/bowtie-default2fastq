#!/usr/bin/env python

from __future__ import division

import os, sys, time
from optparse import OptionParser
from itertools import izip

from seqtools import fastq, io
from seqtools.qseq import QseqRead
from seqtools.sequence import reverse_complement

if __name__ == '__main__':
    usage = """usage: %prog [options] INPUT [OUTFILE]

    Extracts the reads from a bowtie output file and creates a SAM file.
    
    We assume that only unique reads are reported here. See:
    
        http://bowtie-bio.sourceforge.net/manual.shtml#default-bowtie-output
    
    """

    parser = OptionParser(usage=usage)
    parser.add_option("-n", "--readidx", dest="readidx", default=False,
                      action="store_true",
                      help="Uniquify read name by adding :N where N = nth read")
    (options, args) = parser.parse_args()
    
    ## Check input files
    if len(args) == 0:
        infile = sys.stdin
        outfile = sys.stdout
        close_in = False
        close_out = False
    if len(args) > 0:
        if args[0] == '-':
            infile = sys.stdin
            close_in = False
        else:
            infile = args[0]
            if not os.path.isfile(infile):
                parser.error("Cannot read sequence qseq file")
            infile = io.xopen(infile, 'r')
            close_in = True
        outfile = sys.stdout
        close_out = False
    if len(args) > 1:
        outfile = args[2]
        if os.path.isfile(outfile):
            parser.error("Destination file already exists")
        outfile = io.xopen(outfile, 'w')
        close_out = True
    
    nproc = 0
    nkeep = 0
    readidx = options.readidx
    t0 = time.time()
    
    for (idx, line) in enumerate(infile):
        nproc += 1
        line = line.strip().split()
        read_name = line[0]
        strand = line[1]
        seqname = line[2]
        start = line[4]
        seq = line[4]
        qual = line[5]
        # n_same_hits = line[5]
        # mm_info = line[6]
        if strand == '-':
            seq = reverse_complement(seq)
        if readidx:
            read_name = "%s:%d" % (read_name, idx)
        outfile.write("@%s\n%s\n+\n%s\n" % (read_name, seq, qual))
        
    elapsed = time.time() - t0
    
    if close_in:
        infile.close()
    
    if close_out:
        outfile.close()
    
    sys.stderr.write('========= Summary =========\n')
    sys.stderr.write("Time taken: %.2f seconds\n" % elapsed)
    sys.stderr.write('Reads processed %d\n' % nproc)
    
    
